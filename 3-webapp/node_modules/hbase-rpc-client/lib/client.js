// Generated by CoffeeScript 1.12.7
(function() {
  var Client, Connection, Delete, EventEmitter, Get, Increment, ProtoBuf, Put, Scan, ZooKeeperWatcher, async, builder, crypto, debug, hconstants, md5sum, proto, rDebug, utils, zkDebug, zkProto,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  debug = (require('debug'))('hbase-client');

  rDebug = (require('debug'))('hbase-region');

  zkDebug = (require('debug'))('zk');

  zkProto = require('./zk-protobuf');

  utils = require('./utils');

  crypto = require('crypto');

  async = require('async');

  hconstants = require('./hconstants');

  Connection = require('./connection');

  Get = require('./get');

  Put = require('./put');

  Delete = require('./delete');

  Increment = require('./increment');

  Scan = require('./scan').Scan;

  ZooKeeperWatcher = require('zookeeper-watcher');

  EventEmitter = require('events').EventEmitter;

  ProtoBuf = require("protobufjs");

  ProtoBuf.convertFieldsToCamelCase = true;

  builder = ProtoBuf.loadProtoFile(__dirname + "/../proto/Client.proto");

  proto = builder.build();

  md5sum = function(data) {
    return crypto.createHash('md5').update(data).digest('hex');
  };

  module.exports = Client = (function(superClass) {
    extend(Client, superClass);

    function Client(options) {
      this._deleteCachedLocation = bind(this._deleteCachedLocation, this);
      this._clearCachedLocationForServer = bind(this._clearCachedLocationForServer, this);
      this._handleConnectionClose = bind(this._handleConnectionClose, this);
      this._handleConnectionError = bind(this._handleConnectionError, this);
      this.getRegionConnection = bind(this.getRegionConnection, this);
      this.prefetchRegionCache = bind(this.prefetchRegionCache, this);
      this.processBatch = bind(this.processBatch, this);
      this.incrementColumnValue = bind(this.incrementColumnValue, this);
      this.increment = bind(this.increment, this);
      this.mdelete = bind(this.mdelete, this);
      this.mput = bind(this.mput, this);
      this.mget = bind(this.mget, this);
      this["delete"] = bind(this["delete"], this);
      this.put = bind(this.put, this);
      this.checkAndDelete = bind(this.checkAndDelete, this);
      this.checkAndPut = bind(this.checkAndPut, this);
      this.get = bind(this.get, this);
      this.getScanner = bind(this.getScanner, this);
      this._multiAction = bind(this._multiAction, this);
      this._action = bind(this._action, this);
      this._findRegionName = bind(this._findRegionName, this);
      this.getCachedLocation = bind(this.getCachedLocation, this);
      this.cacheLocation = bind(this.cacheLocation, this);
      this.locateRegionInMeta = bind(this.locateRegionInMeta, this);
      this.locatePreviousRegion = bind(this.locatePreviousRegion, this);
      this.locateRegion = bind(this.locateRegion, this);
      this.ensureZookeeperTrackers = bind(this.ensureZookeeperTrackers, this);
      this._zkWatch = bind(this._zkWatch, this);
      Client.__super__.constructor.call(this);
      options.zookeeperRoot = options.zookeeperRoot || "/hbase";
      if (options.zookeeper && typeof options.zookeeper.quorum === "string") {
        options.zookeeperHosts = options.zookeeper.quorum.split(hconstants.SERVERNAME_SEPARATOR);
      }
      this.zk = new ZooKeeperWatcher({
        hosts: options.zookeeperHosts,
        root: options.zookeeperRoot,
        reconnectTimeout: options.zookeeperReconnectTimeout
      });
      this.servers = {};
      this.options = options;
      this.cachedRegionLocations = {};
      this.rpcTimeout = options.rpcTimeout || hconstants.RPC_TIMEOUT;
      this.callTimeout = options.callTimeout || hconstants.CALL_TIMEOUT;
      this.maxActionRetries = options.maxActionRetries || hconstants.MAX_ACTION_RETRIES;
      this.tcpNoDelay = options.tcpNoDelay || false;
      this.tcpKeepAlive = options.tcpKeepAlive || true;
      this.realUser = options.realUser;
      this.effectiveUser = options.effectiveUser || hconstants.EFFECTIVE_USER;
      this.zkStart = "init";
      this._zkStartListener = [];
      this.rootRegionZKPath = options.rootRegionZKPath || '/meta-region-server';
      this._prefetchRegionCacheList = {};
      this._prefetchRegionCacheListInProgress = {};
      this.ensureZookeeperTrackers((function(_this) {
        return function(err) {
          if (err) {
            return _this.emit('error', err);
          }
        };
      })(this));
    }

    Client.prototype._zkWatch = function() {
      this.zk.unWatch(this.rootRegionZKPath);
      return this.zk.watch(this.rootRegionZKPath, (function(_this) {
        return function(err, value, zstat) {
          var firstStart, oldServer, rootServer, serverName;
          firstStart = _this.zkStart !== "done";
          if (err) {
            setTimeout(function() {
              return _this._zkWatch();
            }, hconstants.SOCKET_RETRY_WAIT_MS);
            zkDebug("[%s] [worker:%s] [hbase-client] zookeeper watch error: %s", new Date(), process.pid, err.stack);
            if (firstStart) {
              _this.zkStart = "error";
              _this.emit("error", err);
            }
            return;
          }
          _this.zkWatchTimeoutCount = 1;
          rootServer = zkProto.decodeMeta(value);
          if (!rootServer) {
            console.log("Failed to parse rootServer");
            return;
          }
          _this.zkStart = "done";
          oldServer = _this.rootServer || {
            server: {
              hostName: 'none',
              port: 'none'
            }
          };
          _this.rootServer = rootServer.server;
          serverName = _this.getServerName(_this.rootServer);
          return _this.getRegionConnection(serverName, function(err, server) {
            if (err) {
              return cb(err);
            }
            zkDebug("zookeeper start done, got new root " + serverName + ", old " + (oldServer != null ? oldServer.hostName : void 0) + ":" + (oldServer != null ? oldServer.port : void 0));
            if (firstStart) {
              return _this.emit("ready");
            }
          });
        };
      })(this));
    };

    Client.prototype.ensureZookeeperTrackers = function(cb) {
      var timeout;
      if (this.zkStart === "done") {
        return cb();
      }
      this._zkStartListener.push(cb);
      if (this.zkStart === "starting") {
        return;
      }
      this.zkStart = "starting";
      timeout = setTimeout((function(_this) {
        return function() {
          var err;
          err = "Failed to connect to zookeeper. zkHosts: [" + _this.options.zookeeperHosts + "] zkRoot: '" + _this.options.zookeeperRoot + "'";
          zkDebug(err);
          return _this.emit("error", err);
        };
      })(this), this.rpcTimeout);
      this.once('ready', (function(_this) {
        return function() {
          var callback, results1;
          clearTimeout(timeout);
          results1 = [];
          while (_this._zkStartListener.length) {
            callback = _this._zkStartListener.pop();
            results1.push(callback());
          }
          return results1;
        };
      })(this));
      return this.zk.once("connected", this._zkWatch);
    };

    Client.prototype.getServerName = function(hostname, port) {
      if (typeof hostname === 'object') {
        port = hostname.port;
        hostname = hostname.hostName;
      }
      return hostname + ":" + port;
    };

    Client.prototype.locateRegion = function(table, row, useCache, cb) {
      if (typeof useCache === 'function') {
        cb = useCache;
        useCache = true;
      }
      rDebug("locateRegion table: " + table + " row: " + row);
      if (!Buffer.isBuffer(table)) {
        table = new Buffer(table);
      }
      row = new Buffer(row || [0]);
      return this.ensureZookeeperTrackers((function(_this) {
        return function(err) {
          if (err) {
            return cb(err);
          }
          return _this.locateRegionInMeta(table, row, useCache, cb);
        };
      })(this));
    };

    Client.prototype.locatePreviousRegion = function(table, endKey, cb) {
      return this.prefetchRegionCache(table, (function(_this) {
        return function() {
          var ref, region, regionName;
          if (endKey.length) {
            return _this.locateRegion(table, endKey, cb);
          }
          ref = _this.cachedRegionLocations[table];
          for (regionName in ref) {
            region = ref[regionName];
            if (region.endKey.length === 0) {
              return cb(null, region);
            }
          }
        };
      })(this));
    };

    Client.prototype.locateRegionInMeta = function(table, row, useCache, cb) {
      var o, region, req;
      rDebug("locateRegionInMeta table: " + table + " row: " + row);
      region = this.createRegionName(table, row, '', true);
      if (utils.bufferCompare(table, hconstants.META_TABLE_NAME) === 0) {
        o = {
          startKey: new Buffer(0),
          endKey: new Buffer(0),
          name: hconstants.META_REGION_NAME,
          server: this.getServerName(this.rootServer.hostName, this.rootServer.port)
        };
        return cb(null, o);
      }
      req = {
        region: {
          type: "REGION_NAME",
          value: hconstants.META_REGION_NAME
        },
        gxt: {
          row: region,
          column: {
            family: "info"
          },
          closestRowBefore: true
        }
      };
      return this.prefetchRegionCache(table, (function(_this) {
        return function() {
          var cachedRegion;
          if (useCache) {
            cachedRegion = _this.getCachedLocation(table, row);
            if (cachedRegion) {
              return cb(null, cachedRegion);
            }
          } else {
            _this._deleteCachedLocation(table, row);
          }
          return _this.getRegionConnection(_this.rootServer.hostName, _this.rootServer.port, function(err, server) {
            return server.rpc.Get(req, function(err, response) {
              if (err) {
                rDebug("locateRegionInMeta error: " + err);
                return cb(err);
              }
              if (response != null ? response.result : void 0) {
                region = _this._parseRegionInfo(_this._parseResponse(response.result));
              }
              if (!region.server) {
                err = "region for table " + table + " not found";
                cb(err);
                return rDebug(err);
              }
              _this.cacheLocation(table, region);
              return cb(null, region);
            });
          });
        };
      })(this));
    };

    Client.prototype._parseRegionInfo = function(res) {
      var region, regionInfo;
      if (!(res && Object.keys(res).length)) {
        return null;
      }
      regionInfo = res.cols['info:regioninfo'].value;
      regionInfo = regionInfo.slice(regionInfo.toString().indexOf('PBUF') + 4);
      regionInfo = proto.RegionInfo.decode(regionInfo);
      region = {
        server: res.cols['info:server'].value,
        startKey: regionInfo.startKey.toBuffer(),
        endKey: regionInfo.endKey.toBuffer(),
        name: res.row,
        ts: res.cols['info:server'].timestamp.toString()
      };
      return region;
    };

    Client.prototype.cacheLocation = function(table, region) {
      var base;
      if ((base = this.cachedRegionLocations)[table] == null) {
        base[table] = {};
      }
      return this.cachedRegionLocations[table][region.name] = region;
    };

    Client.prototype.getCachedLocation = function(table, row) {
      var cachedRegion;
      rDebug("Trying to find cached regionLocation for table " + table);
      cachedRegion = this._findRegionName(table, row);
      if (cachedRegion) {
        return this.cachedRegionLocations[table][cachedRegion];
      }
      rDebug("Couldn't find cached regionLocation for table " + table);
      return null;
    };

    Client.prototype._findRegionName = function(table, row) {
      var cachedRegion, cachedRegions, endKey, i, len, startKey;
      if (!(this.cachedRegionLocations[table] && Object.keys(this.cachedRegionLocations[table]).length > 0)) {
        return null;
      }
      cachedRegions = Object.keys(this.cachedRegionLocations[table]);
      for (i = 0, len = cachedRegions.length; i < len; i++) {
        cachedRegion = cachedRegions[i];
        startKey = this.cachedRegionLocations[table][cachedRegion].startKey;
        endKey = this.cachedRegionLocations[table][cachedRegion].endKey;
        if ((endKey.length === 0 || utils.bufferCompare(row, endKey) < 0) && (startKey.length === 0 || utils.bufferCompare(row, startKey) >= 0)) {
          rDebug("Found cached regionLocation " + cachedRegion);
          return cachedRegion;
        }
      }
      return null;
    };

    Client.prototype.printRegion = function(region) {
      var o;
      return o = {
        startKey: region.startKey.toString(),
        endKey: region.endKey.toString(),
        name: region.name.toString(),
        ts: region.ts.toString(),
        server: region.server.toString()
      };
    };

    Client.prototype._parseResponse = function(res) {
      var cols, columns, o, ref, row;
      if (!(res != null ? (ref = res.cell) != null ? ref.length : void 0 : void 0)) {
        return null;
      }
      row = null;
      cols = {};
      columns = res.cell.map(function(cell) {
        var f, o, q, t, v;
        row = cell.row.toBuffer();
        f = cell.family.toBuffer();
        q = cell.qualifier.toBuffer();
        v = cell.value.toBuffer();
        t = cell.timestamp;
        o = {
          value: v,
          timestamp: t
        };
        if (cols[f + ":" + q]) {
          if (!Array.isArray(cols[f + ":" + q])) {
            cols[f + ":" + q] = [cols[f + ":" + q]];
          }
          cols[f + ":" + q].push(o);
        } else {
          cols[f + ":" + q] = o;
        }
        return {
          family: f,
          qualifier: q,
          value: v,
          timestamp: t
        };
      });
      o = {
        row: row,
        cols: cols,
        columns: columns
      };
      return o;
    };

    Client.prototype.createRegionName = function(table, startKey, id, newFormat) {
      var b, delim, md5;
      if (!Buffer.isBuffer(table)) {
        table = new Buffer(table);
      }
      startKey = new Buffer(startKey || 0);
      id = new Buffer((id != null ? id.toString() : void 0) || 0);
      delim = new Buffer(',');
      b = Buffer.concat([table, delim, startKey, delim, id]);
      md5 = new Buffer(md5sum(b));
      delim = new Buffer('.');
      if (newFormat) {
        return Buffer.concat([b, delim, md5, delim]);
      }
      return b;
    };

    Client.prototype._action = function(method, table, obj, useCache, retry, cb) {
      if (typeof useCache === 'function') {
        cb = useCache;
        useCache = true;
        retry = 0;
      } else if (typeof retry === 'function') {
        cb = retry;
        retry = 0;
      }
      return this.locateRegion(table, obj.row, useCache, (function(_this) {
        return function(err, location) {
          if (err) {
            return cb(err);
          }
          return _this.getRegionConnection(location.server.toString(), function(err, server) {
            var callback, comparator, req;
            if (err) {
              return cb(err);
            }
            callback = function(err) {
              if (err && retry <= _this.maxActionRetries && _this._isRetryException(err)) {
                debug("Error occured on server: " + (location.server.toString()) + " region: " + location.name);
                debug("Retrying " + (++retry) + "-time " + method + " on " + table);
                return _this._action.apply(_this, [method, table, obj, false, retry, cb]);
              }
              return cb.apply(null, arguments);
            };
            if (method === 'get') {
              req = {
                region: {
                  type: "REGION_NAME",
                  value: location.name
                },
                gxt: obj.getFields()
              };
              return server.rpc.Get(req, function(err, response) {
                if (err) {
                  return callback(err);
                }
                return cb(null, _this._parseResponse(response.result));
              });
            } else if (method === 'put' || method === 'delete' || method === 'increment') {
              req = {
                region: {
                  type: "REGION_NAME",
                  value: location.name
                },
                mutation: obj.getFields()
              };
              return server.rpc.Mutate(req, callback);
            } else if (method === 'checkAndPut' || method === 'checkAndDelete') {
              comparator = new proto.BinaryComparator({
                comparable: {
                  value: obj.value
                }
              });
              req = {
                region: {
                  type: "REGION_NAME",
                  value: location.name
                },
                mutation: obj.op.getFields(),
                condition: {
                  row: obj.row,
                  family: obj.family,
                  qualifier: obj.qualifier,
                  compareType: 'EQUAL',
                  comparator: {
                    name: 'org.apache.hadoop.hbase.filter.BinaryComparator',
                    serializedComparator: comparator.encode()
                  }
                }
              };
              return server.rpc.Mutate(req, callback);
            }
          });
        };
      })(this));
    };

    Client.prototype._multiAction = function(table, multiActions, useCache, retry, cb) {
      var result;
      if (typeof useCache === 'function') {
        cb = useCache;
        useCache = true;
        retry = 0;
      } else if (typeof retry === 'function') {
        cb = retry;
        retry = 0;
      }
      result = [];
      return async.each(Object.keys(multiActions), (function(_this) {
        return function(serverName, done) {
          var actions, operations, ref, region, req;
          req = {
            regionAction: []
          };
          ref = multiActions[serverName];
          for (region in ref) {
            actions = ref[region];
            operations = [];
            operations = actions.map(function(action) {
              var ref1;
              if (action.method === 'get') {
                return {
                  gxt: action.getFields()
                };
              } else if ((ref1 = action.method) === 'put' || ref1 === 'delete') {
                return {
                  mutation: action.getFields()
                };
              }
            });
            req.regionAction.push({
              region: {
                type: "REGION_NAME",
                value: region
              },
              action: operations
            });
          }
          return _this.getRegionConnection(serverName, function(err, server) {
            if (err) {
              return done(err);
            }
            return server.rpc.Multi(req, function(err, res) {
              var i, j, len, len1, o, ref1, ref2, response, serverResult;
              if (err) {
                return done(err);
              }
              ref1 = res.regionActionResult;
              for (i = 0, len = ref1.length; i < len; i++) {
                serverResult = ref1[i];
                if (serverResult.exception) {
                  result.push(serverResult.exception);
                  continue;
                }
                ref2 = serverResult.resultOrException;
                for (j = 0, len1 = ref2.length; j < len1; j++) {
                  response = ref2[j];
                  if (response.exception) {
                    result.push(response.exception);
                    continue;
                  }
                  o = _this._parseResponse(response.result);
                  result.push(o || response.result);
                }
              }
              return done();
            });
          });
        };
      })(this), function(err) {
        return cb(err, result);
      });
    };

    Client.prototype.getScanner = function(table, startRow, stopRow) {
      return new Scan(table, startRow, stopRow, this);
    };

    Client.prototype.get = function(table, get, cb) {
      debug("get on table: " + table);
      return this._action('get', table, get, cb);
    };

    Client.prototype.checkAndPut = function(table, row, family, qualifier, value, put, cb) {
      var o;
      o = {
        row: row,
        family: family,
        qualifier: qualifier,
        value: value,
        op: put
      };
      debug("checkAndPut on table: " + table);
      return this._action('checkAndPut', table, o, cb);
    };

    Client.prototype.checkAndDelete = function(table, row, family, qualifier, value, del, cb) {
      var o;
      o = {
        row: row,
        family: family,
        qualifier: qualifier,
        value: value,
        op: del
      };
      debug("checkAndDelete on table: " + table);
      return this._action('checkAndDelete', table, o, cb);
    };

    Client.prototype.put = function(table, put, cb) {
      debug("put on table: " + table);
      return this._action('put', table, put, cb);
    };

    Client.prototype["delete"] = function(table, del, cb) {
      debug("delete on table: " + table);
      return this._action('delete', table, del, cb);
    };

    Client.prototype.mget = function(table, rows, columns, opts, cb) {
      var column, get, i, j, len, len1, row, workingList;
      if (typeof columns === 'function') {
        cb = columns;
        opts = {};
        columns = [];
      } else if (typeof opts === 'function') {
        cb = opts;
        opts = {};
      }
      if (!(Array.isArray(rows) && rows.length > 0)) {
        return cb("Input is expected to be a non-empty array");
      }
      debug("mget on table: " + table + " " + rows.length + " rows");
      workingList = [];
      for (i = 0, len = rows.length; i < len; i++) {
        row = rows[i];
        if (row instanceof Get) {
          get = row;
        } else {
          get = new Get(row);
          if (columns) {
            for (j = 0, len1 = columns.length; j < len1; j++) {
              column = columns[j];
              column = column.split(':');
              get.addColumn(column[0], column[1]);
            }
          }
        }
        get.method = 'get';
        workingList.push(get);
      }
      return this.processBatch(table, workingList, true, 0, function(err, results) {
        return cb(err, results);
      });
    };

    Client.prototype.mput = function(table, rows, opts, cb) {
      var column, columns, err, i, len, put, row, value, workingList;
      if (typeof columns === 'function') {
        cb = columns;
        opts = {};
        columns = [];
      } else if (typeof opts === 'function') {
        cb = opts;
        opts = {};
      }
      if (!(Array.isArray(rows) && rows.length > 0)) {
        return cb("Input is expected to be a non-empty array");
      }
      debug("mput on table: " + table + " " + rows.length + " rows");
      workingList = [];
      for (i = 0, len = rows.length; i < len; i++) {
        row = rows[i];
        if (row instanceof Put) {
          put = row;
        } else {
          put = new Put(row.row);
          for (column in row) {
            value = row[column];
            if (column === 'row') {
              continue;
            }
            column = column.split(':');
            try {
              put.add(column[0], column[1], value);
            } catch (error) {
              err = error;
              return cb(err);
            }
          }
        }
        put.method = 'put';
        workingList.push(put);
      }
      return this.processBatch(table, workingList, true, 0, function(err, results) {
        return cb(err, results);
      });
    };

    Client.prototype.mdelete = function(table, rows, opts, cb) {
      var columns, del, i, len, row, workingList;
      if (typeof columns === 'function') {
        cb = columns;
        opts = {};
        columns = [];
      } else if (typeof opts === 'function') {
        cb = opts;
        opts = {};
      }
      if (!(Array.isArray(rows) && rows.length > 0)) {
        return cb("Input is expected to be a non-empty array");
      }
      debug("mdelete on table: " + table + " " + rows.length + " rows");
      workingList = [];
      for (i = 0, len = rows.length; i < len; i++) {
        row = rows[i];
        if (row instanceof Delete) {
          del = row;
        } else {
          del = new Delete(row);
        }
        del.method = 'delete';
        workingList.push(del);
      }
      return this.processBatch(table, workingList, true, 0, function(err, results) {
        return cb(err, results);
      });
    };

    Client.prototype.increment = function(table, increment, cb) {
      debug("increment on table: " + table);
      return this._action('increment', table, increment, cb);
    };

    Client.prototype.incrementColumnValue = function(table, row, cf, qualifier, value, cb) {
      var increment;
      increment = new Increment(row);
      increment.add(cf, qualifier, value);
      return this.increment(table, increment, cb);
    };

    Client.prototype.mutateRow = function() {
      throw new Error('mutateRow not implemented');
    };

    Client.prototype.append = function() {
      throw new Error('append is not implemented');
    };

    Client.prototype.getRowOrBefore = function() {
      throw new Error('getRowOrBefore is not implemented');
    };

    Client.prototype.processBatch = function(table, workingList, useCache, retry, cb) {
      var actionsByServer;
      if (typeof useCache === 'function') {
        cb = useCache;
        useCache = true;
      }
      actionsByServer = {};
      workingList = workingList.filter(function(item) {
        return item != null;
      });
      if (workingList.length === 0) {
        return cb(null, []);
      }
      return async.each(workingList, (function(_this) {
        return function(row, done) {
          return _this.locateRegion(table, row.getRow(), useCache, function(err, location) {
            var base, name, name1;
            if (err) {
              return done(err);
            }
            if (actionsByServer[name = location.server] == null) {
              actionsByServer[name] = {};
            }
            if ((base = actionsByServer[location.server])[name1 = location.name] == null) {
              base[name1] = [];
            }
            actionsByServer[location.server][location.name].push(row);
            return done();
          });
        };
      })(this), (function(_this) {
        return function(err) {
          if (err) {
            return cb(err);
          }
          return _this._multiAction(table, actionsByServer, useCache, retry, function(err, results) {
            var i, len, result;
            if (err) {
              return cb(err);
            }
            for (i = 0, len = results.length; i < len; i++) {
              result = results[i];
              if (retry > _this.maxActionRetries && _this._isException(result)) {
                return cb(result);
              }
              if (_this._isRetryException(result)) {
                debug("Retrying " + (++retry) + "-time on " + table);
                return _this.processBatch.apply(_this, [table, workingList, false, retry, cb]);
              }
            }
            return cb(null, results);
          });
        };
      })(this));
    };

    Client.prototype.prefetchRegionCache = function(table, cb) {
      var event, scan, startRow, stopRow, work;
      if (this._prefetchRegionCacheList[table] || utils.bufferCompare(table, hconstants.META_TABLE_NAME) === 0) {
        return cb();
      }
      debug("prefetchRegionCache for table: " + table);
      event = "prefetch-" + table;
      if (this._prefetchRegionCacheListInProgress[event]) {
        return this._prefetchRegionCacheListInProgress[event].push(cb);
      }
      this.once(event, (function(_this) {
        return function() {
          var callback, results1;
          results1 = [];
          while (_this._prefetchRegionCacheListInProgress[event].length) {
            callback = _this._prefetchRegionCacheListInProgress[event].pop();
            results1.push(callback());
          }
          return results1;
        };
      })(this));
      this._prefetchRegionCacheListInProgress[event] = [];
      startRow = this.createRegionName(table, null, hconstants.ZEROS, false);
      stopRow = this.createRegionName(utils.bufferIncrement(table), null, hconstants.ZEROS, false);
      scan = this.getScanner(hconstants.META_TABLE_NAME, startRow, stopRow);
      work = true;
      return async.whilst(function() {
        return work;
      }, (function(_this) {
        return function(done) {
          return scan.next(function(err, regionRow) {
            var region;
            if (err) {
              return done(err);
            }
            if (!regionRow.row) {
              _this._prefetchRegionCacheList[table] = true;
              work = false;
              return done();
            }
            region = _this._parseRegionInfo(regionRow);
            if (region) {
              _this.cacheLocation(table, region);
            }
            return done();
          });
        };
      })(this), (function(_this) {
        return function(err) {
          if (err) {
            console.log(err);
          }
          _this.emit(event);
          delete _this._prefetchRegionCacheListInProgress[event];
          return cb();
        };
      })(this));
    };

    Client.prototype.getRegionConnection = function(hostname, port, cb) {
      var ref, server, serverName, timer;
      if (typeof port === 'function') {
        cb = port;
        serverName = hostname;
        ref = hostname.split(':'), hostname = ref[0], port = ref[1];
      } else {
        serverName = this.getServerName(hostname, port);
      }
      rDebug('getRegionConnection', serverName);
      server = this.servers[serverName];
      if (server) {
        if (server.state === "ready") {
          rDebug("getRegionConnection from cache (servers: " + (Object.keys(this.servers).length) + "), " + serverName);
          cb(null, server);
        } else {
          server.on('ready', function() {
            return cb(null, server);
          });
        }
        return;
      }
      rDebug("getRegionConnection connecting to " + serverName);
      server = new Connection({
        host: hostname,
        port: port,
        rpcTimeout: this.rpcTimeout,
        callTimeout: this.callTimeout,
        tcpNoDelay: this.tcpNoDelay,
        tcpKeepAlive: this.tcpKeepAlive,
        logger: this.logger,
        realUser: this.realUser,
        effectiveUser: this.effectiveUser
      });
      server.state = "connecting";
      this.servers[serverName] = server;
      timer = null;
      timer = setTimeout((function(_this) {
        return function() {
          var err;
          err = (serverName + " connect timeout, ") + _this.rpcTimeout + " ms";
          _this._handleConnectionError(err, serverName, timer);
        };
      })(this), this.rpcTimeout);
      server.once("connect", (function(_this) {
        return function() {
          rDebug("%s connected, total %d connections", serverName, Object.keys(_this.servers).length);
          server.state = "ready";
          server.emit('ready');
          clearTimeout(timer);
          timer = null;
          return cb(null, server);
        };
      })(this));
      server.once("connectError", this._handleConnectionError.bind(this, null, serverName, timer));
      return server.once("close", this._handleConnectionClose.bind(this, serverName));
    };

    Client.prototype._handleConnectionError = function(err, serverName, timer) {
      var server;
      rDebug("_handleConnectionError server: " + serverName + " msg: " + err.message);
      if (timer) {
        clearTimeout(timer);
        timer = null;
      }
      if (err) {
        debug(err);
      }
      if (!this.servers[serverName]) {
        return;
      }
      server = this.servers[serverName];
      delete this.servers[serverName];
      return server.removeAllListeners();
    };

    Client.prototype._handleConnectionClose = function(serverName) {
      rDebug("_handleConnectionClose server: " + serverName);
      this.servers[serverName].removeAllListeners();
      delete this.servers[serverName];
      return this._clearCachedLocationForServer(serverName);
    };

    Client.prototype._clearCachedLocationForServer = function(serverName) {
      var ref, region, regionName, regions, results1, table;
      ref = this.cachedRegionLocations;
      results1 = [];
      for (table in ref) {
        regions = ref[table];
        results1.push((function() {
          var results2;
          results2 = [];
          for (regionName in regions) {
            region = regions[regionName];
            if (region.server.toString() === serverName) {
              delete this.cachedRegionLocations[table];
              results2.push(this._prefetchRegionCacheList[table] = false);
            } else {
              results2.push(void 0);
            }
          }
          return results2;
        }).call(this));
      }
      return results1;
    };

    Client.prototype._deleteCachedLocation = function(table, row) {
      var cachedRegion;
      cachedRegion = this._findRegionName(table, row);
      if (cachedRegion) {
        return delete this.cachedRegionLocations[table][cachedRegion];
      }
    };

    Client.prototype._isException = function(err) {
      return !!(err.exceptionClassName || err.name);
    };

    Client.prototype._isRetryException = function(err) {
      var errName;
      errName = err.exceptionClassName || err.name;
      if (!errName) {
        return false;
      }
      debug("Got error from region server: " + errName);
      errName = errName.toLowerCase();
      return errName.indexOf('org.apache.hadoop.hbase.') >= 0 || errName.indexOf('offline') >= 0 || errName.indexOf('noserver') >= 0 || errName.indexOf('notserving') >= 0;
    };

    return Client;

  })(EventEmitter);

}).call(this);
